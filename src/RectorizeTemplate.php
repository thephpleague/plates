<?php

declare(strict_types=1);

namespace League\Plates;

use League\Plates\Template\DoNotAddItInConstructorInterface;
use League\Plates\Template\Template;
use League\Plates\Template\TemplateClass;
use League\Plates\Template\TemplateClassInterface;
use PhpParser\Comment\Doc;
use PhpParser\Node;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Name;
use PhpParser\Node\Param;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\UnionType;
use PHPStan\Type\NullType;
use PHPStan\Type\Type;
use Rector\Core\PhpParser\Printer\BetterStandardPrinter;
use Rector\Core\Rector\AbstractRector;
use Rector\Core\ValueObject\MethodName;
use Rector\NodeTypeResolver\NodeTypeResolver\ParamTypeResolver;
use Rector\StaticTypeMapper\ValueObject\Type\FullyQualifiedObjectType;
use Symplify\RuleDocGenerator\ValueObject\CodeSample\CodeSample;
use Symplify\RuleDocGenerator\ValueObject\RuleDefinition;

/**
 * @see \Rector\Tests\DeadCode\Rector\ClassMethod\RemoveUnusedConstructorParamRector\RemoveUnusedConstructorParamRectorTest
 */
final class RectorizeTemplate extends AbstractRector
{
    public const CLASS_TO_NOT_ADD_IN_CONSTRUCTOR = [Template::class, TemplateClass::class, DoNotAddItInConstructorInterface::class];

    public function __construct(
        private readonly ParamTypeResolver $paramTypeResolver
    ) {
    }

    public function getRuleDefinition(): RuleDefinition
    {
        return new RuleDefinition('Duplicate diplay to constructor except Template', [new CodeSample(
            <<<'CODE_SAMPLE'
final class SomeTemplate
{
    public function display(string $name, Template $t): void
    {
        // ...
    }
}
CODE_SAMPLE
            ,
            <<<'CODE_SAMPLE'
final class SomeClass
{
    public function display(string $name, Template $t): void
    {
        // ...
    }

    public function __construct(public string $name)
    {
    }
}
CODE_SAMPLE
        )]);
    }

    /**
     * @return array<class-string<Node>>
     */
    public function getNodeTypes(): array
    {
        return [Class_::class];
    }

    /**
     * @param Class_ $node
     */
    public function refactor(Node $node): ?Node
    {
        $implementedInterfaces = array_map(static fn (Name $interface): string => $interface->toString(), $node->implements);
        if (! \in_array(TemplateClassInterface::class, $implementedInterfaces, true)) {
            return null;
        }

        $displayMethod = $node->getMethod('display');
        if (null === $displayMethod) {
            return null;
        }

        if ([] === $displayMethod->params) {
            return $this->removeConstructor($node);
        }

        $paramsForConstructor = [];
        $docBlockForConstructor = [];
        $methodDocBlock = $displayMethod?->getDocComment()?->getText() ?? '';
        foreach ($displayMethod->params as $parameter) {
            $paramType = $this->paramTypeResolver->resolve($parameter);
            if ($paramType instanceof FullyQualifiedObjectType && ! $this->mustAddObjectInConstructor($paramType)) {
                continue;
            }

            $paramDocBlock = $this->getParameterDocblock($methodDocBlock, $this->getName($parameter));
            if (null !== $paramDocBlock) {
                $docBlockForConstructor[] = $paramDocBlock;
            }

            $cloneParameter = clone $parameter;
            $cloneParameter->flags = 1;

            if ($parameter->default instanceof Expr
                && (! $this->hasNullType($paramType)
                && $parameter->default instanceof ConstFetch
                && $this->hasNullValue($parameter))) {
                $this->addTypeToParameter($cloneParameter, 'null');
            }

            $paramsForConstructor[] = $cloneParameter;
        }

        if ([] === $paramsForConstructor) {
            return $this->removeConstructor($node);
        }

        $constructor = $node->getMethod(MethodName::CONSTRUCT);
        $docBlockConstructor = $constructor?->getDocComment();
        $newDocBlockConstructor = new Doc("/**\n * ".trim("Autogenerated constructor.\n * ".implode("\n * ", $docBlockForConstructor), "\n *")."\n */");
        if ($paramsForConstructor === $constructor?->params || $docBlockConstructor === $newDocBlockConstructor) { // TODO compare docblock
            return null;
        }

        $this->removeConstructor($node);

        $constructor = new ClassMethod('__construct', [
            'flags' => Class_::MODIFIER_PUBLIC,
            'params' => $paramsForConstructor,
        ]);
        $constructor->setDocComment($newDocBlockConstructor);

        $node->stmts[] = $constructor;

        return $node;
    }

    private function hasNullType(Type $type): bool
    {
        if ($type instanceof NullType) {
            return true;
        }

        if ($type instanceof \PHPStan\Type\UnionType) {
            foreach ($type->getTypes() as $type) {
                if ($this->hasNullType($type)) {
                    return true;
                }
            }
        }

        return false;
    }

    private function hasNullValue(Param $param): bool
    {
        $text = (new BetterStandardPrinter())->print($param);

        return str_ends_with($text, 'null');
    }

    private function removeConstructor(Class_ $class): null
    {
        foreach ($class->stmts as $key => $stmt) {
            if ($stmt instanceof ClassMethod && MethodName::CONSTRUCT === $stmt->name->toString()) {
                unset($class->stmts[$key]);

                break;
            }
        }

        return null;
    }

    private function getParameterDocblock(?string $methodDocblock, string $parameterName): ?string
    {
        if (null === $methodDocblock) {
            return null;
        }

        // Regular expression to match a docblock for a specific parameter
        $pattern = '/@param\s+[^$]*?\$'.$parameterName.'\b([^@]*)/';

        $patternIsFound = preg_match($pattern, $methodDocblock, $matches);

        if ($patternIsFound) {
            return trim($matches[0], '*/ '."\n");
        }

        return null;
    }

    private function mustAddObjectInConstructor(FullyQualifiedObjectType $paramType): bool
    {
        if (\in_array($paramType->getClassName(), self::CLASS_TO_NOT_ADD_IN_CONSTRUCTOR, true)) {
            return false;
        }

        foreach (self::CLASS_TO_NOT_ADD_IN_CONSTRUCTOR as $classToCheck) {
            if (is_subclass_of($paramType->getClassName(), $classToCheck)) {
                return false;
            }
        }

        return true;
    }

    private function addTypeToParameter(Param $param, string $type): void
    {
        $existingType = $this->nodeTypeResolver->getType($param);

        if ($existingType instanceof \PHPStan\Type\UnionType) {
            $existingTypes = $existingType->getTypes();
            $newTypes = [...$existingTypes, new NullType()];
            $param->type = new UnionType($newTypes);

            return;
        }

        if (null === $existingType) {
            $param->type = new NullType();

            return;
        }

        $param->type = null;
        // The following code is not working
        // $param->type = new UnionType([$existingType, new \PHPStan\Type\NullType()]);
        // Get it worked using nullable_type_declaration_for_default_null_value for phpcsfixer
    }
}
